# How-to deal with reflection in GraalVM
Building native images relies on static code analysis to detect which code will be reachable. This AOT (ahead of time) compilation does not work for dynamic features like Java reflection. (Other dynamic features are dynamic proxies or class path resources.)

To use such features in native apps, we have to provide some configuration files to the tool native-image. These configuration files can be generated by using an tracing agent that tracks all usages of dynamic features while executing the app on a JVM with JIT (just in time) compilation.

This example is used in workshops concerning native Java apps.

# Using reflection with JIT-compiler
```shell
javac ReflectionExample.java SomeClass.java                                                                                                                                                              ─╯
java ReflectionExample SomeClass foo
java ReflectionExample SomeClass ping
```

# Compile to native
```shell
native-image --no-fallback ReflectionExample
./reflectionexample SomeClass foo
./reflectionexample SomeClass ping
```

# Using tracing agent to generate configuration files
```shell
mkdir -p META-INF/native-image
java \
  -agentlib:native-image-agent=config-output-dir=META-INF/native-image,config-write-period-secs=300,config-write-initial-delay-secs=5 \
  ReflectionExample SomeClass foo
cat META-INF/native-image/reflect-config.json
```

# Compile to native with configuration files -> foo() works, ping() still fails
```shell
native-image --no-fallback ReflectionExample
./reflectionexample SomeClass foo
./reflectionexample SomeClass ping
```
